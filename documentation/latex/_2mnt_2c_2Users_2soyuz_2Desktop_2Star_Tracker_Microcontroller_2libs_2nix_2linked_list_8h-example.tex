\hypertarget{_2mnt_2c_2Users_2soyuz_2Desktop_2Star_Tracker_Microcontroller_2libs_2nix_2linked_list_8h-example}{}\section{/mnt/c/\+Users/soyuz/\+Desktop/\+Star\+\_\+\+Tracker\+\_\+\+Microcontroller/libs/nix/linked\+\_\+list.\+h}
Due to the implementation of the Array\+List, an actual variable is required to push\+\_\+tail into the regular list. Because of this, it will insert the parameter which will immediatly leave scope. This means that a different implementation which copies the value is required.

\begin{DoxyVerb}int i = 0;
int j = 1;
int k = 2;
LinkedListNode<int> node1(i, NULL, NULL);
LinkedListNode<int> node2(j, &node1, NULL);
LinkedListNode<int> node3(k, &node2, NULL);
// node1.next = node2, node2.prev = node1, node2.next = node3, node3.prev = node2.
// node1.prev = NULL, node3.next = NULL.


LinkedListNode<int>* it = &node1;
it = it->next; // node2
it = it->next; // node3
\end{DoxyVerb}



\begin{DoxyTemplParams}{Template Parameters}
{\em T} & The datatype to be stored.\\
\hline
\end{DoxyTemplParams}
\begin{DoxyAuthor}{Author}
Tom Creusot
\end{DoxyAuthor}

\begin{DoxyCodeInclude}

\textcolor{preprocessor}{#pragma once}
\textcolor{preprocessor}{#include <iostream>}
\textcolor{preprocessor}{#include "\hyperlink{array__list_8h}{libs/util/array\_list.h}"}
\textcolor{preprocessor}{#include "\hyperlink{util_8h}{libs/util/util.h}"}

\textcolor{keyword}{using namespace }\hyperlink{namespacestd}{std};

\textcolor{keyword}{namespace }\hyperlink{namespaceutil}{util}
\{
\textcolor{keyword}{template} <\textcolor{keyword}{class} T>
\textcolor{keyword}{class }LinkedListNode
\{
\textcolor{keyword}{public}:
    T value;
    LinkedListNode<T>* next;
    LinkedListNode<T>* prev;


    LinkedListNode( T value, LinkedListNode<T>* prev, LinkedListNode<T>* next )
    \{
        this->value = value;
        this->next = next;
        this->prev = prev;

        \textcolor{keywordflow}{if} ( prev != NULL ) prev->next = \textcolor{keyword}{this};
        \textcolor{keywordflow}{if} ( next != NULL ) next->prev = \textcolor{keyword}{this};
    \}



    \textcolor{keywordtype}{void} RemoveNode ( )
    \{
        \textcolor{keywordflow}{if} ( prev != NULL ) prev->next = next;
        \textcolor{keywordflow}{if} ( next != NULL ) next->prev = prev;
        next = NULL;
        prev = NULL;
    \}


    \textcolor{keywordtype}{void} InsertNode ( LinkedListNode<T>* prev, LinkedListNode<T>* next )
    \{
        this->next = next;
        this->prev = prev;
        \textcolor{keywordflow}{if} ( prev != NULL )
        \{
            prev->next = \textcolor{keyword}{this};
        \}
        \textcolor{keywordflow}{if} ( next != NULL )
        \{
            next->prev = \textcolor{keyword}{this};
        \}
    \}
\};







\textcolor{keyword}{template} <\textcolor{keyword}{class} T>
\textcolor{keyword}{class }LinkedList : \textcolor{keyword}{public} \hyperlink{classutil_1_1ArrayList}{util::ArrayList}<T, 0>
\{
\textcolor{keyword}{public}:
    LinkedListNode<T>* head;
    LinkedListNode<T>* tail;
    uint size = 0;


    LinkedList ( ) : ArrayList<T, 0>()
    \{
        head = NULL;
        tail = NULL;
    \}


    ~LinkedList ( )
    \{
        LinkedListNode<T>* node = head;
        \textcolor{keywordflow}{while} ( node != NULL )
        \{
            LinkedListNode<T>* cur = node;
            node = cur->next;
            free(cur);
        \}
    \}



    \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} IsEmpty         ( )\textcolor{keyword}{ const}
\textcolor{keyword}{    }\{
        \textcolor{keywordflow}{return} head == NULL;
    \}



    \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} IsFull      ( )\textcolor{keyword}{ const}
\textcolor{keyword}{    }\{
        \textcolor{keywordflow}{return} \textcolor{keyword}{false};
    \}


    \textcolor{keyword}{inline} uint Size        ( )\textcolor{keyword}{ const}
\textcolor{keyword}{    }\{
        \textcolor{keywordflow}{return} size;
    \}


    \textcolor{keyword}{virtual} T& Get ( uint position )
    \{
        uint i = 0;
        LinkedListNode<T>* it = head;
        \textcolor{keywordflow}{while} ( i < position && it != NULL )
        \{
            i++;
            it = it->next;
        \}
        \textcolor{keywordflow}{return} it->value;
    \}




    \textcolor{keywordtype}{bool} PushBack   ( T val )
    \{
        LinkedListNode<T>* node;
        \textcolor{keywordflow}{if} ( size == 0 )
        \{
            node = \textcolor{keyword}{new} LinkedListNode<T>(val, NULL, NULL);
            head = node;
        \}
        \textcolor{keywordflow}{else}
        \{
            node = \textcolor{keyword}{new} LinkedListNode<T>(val, tail, NULL);
        \}
        tail = node;
        size++;
        \textcolor{keywordflow}{return} \textcolor{keyword}{true};
    \}




    \textcolor{keywordtype}{bool} PushNodeBack   ( LinkedListNode<T>* node )
    \{
        \textcolor{keywordflow}{if} ( head == NULL ) head = node;
        node->RemoveNode();
        node->InsertNode(tail, NULL);
        tail = node;
        size++;
        \textcolor{keywordflow}{return} \textcolor{keyword}{true};
    \}










    T PopBack       ( )
    \{
        \textcolor{keywordflow}{if} ( tail == NULL ) \textcolor{keywordflow}{throw} std::string(\textcolor{stringliteral}{"You cannot pop back when empty"});
        T val = tail->value;
        \textcolor{keywordflow}{if} ( tail->prev != NULL ) \textcolor{comment}{// More than one element.}
        \{
            tail = tail->prev;
            \textcolor{keyword}{delete} tail->next;
            tail->next = NULL;
        \}
        \textcolor{keywordflow}{else}
        \{
            \textcolor{keyword}{delete} tail;
            tail = NULL;
            head = NULL;
        \}
        size--;
        \textcolor{keywordflow}{return} val;
    \}





    T PopFront      ( )
    \{
        \textcolor{keywordflow}{if} ( head == NULL ) \textcolor{keywordflow}{throw} std::string(\textcolor{stringliteral}{"You cannot pop front when empty"});
        T val = head->value;
        \textcolor{keywordflow}{if} ( head->next != NULL ) \textcolor{comment}{// More than one element.}
        \{
            head = head->next;
            \textcolor{keyword}{delete} head->prev;
            head->prev = NULL;
        \}
        \textcolor{keywordflow}{else}
        \{
            \textcolor{keyword}{delete} head;
            head = NULL;
            tail = NULL;
        \}
        size--;
        \textcolor{keywordflow}{return} val;
    \}





    \textcolor{keywordtype}{void} Sort ( \textcolor{keywordtype}{bool} (*inOrder)(T&, T&) )
    \{
        LinkedList<T> list;
        LinkedListNode<T>* first = head;
        LinkedListNode<T>* cur = head;
        \textcolor{comment}{// Moves all the elements from this list to the next.}
        \textcolor{keywordflow}{while} ( head != NULL )
        \{
            \textcolor{comment}{// Finds the most inOrder element in this list.}
            cur = head;
            first = head;
            \textcolor{keywordflow}{while} ( cur != NULL )
            \{
                \textcolor{keywordflow}{if} ( inOrder(cur->value, first->value) )
                \{
                    first = cur;
                \}
                cur = cur->next;
            \}
            \textcolor{comment}{// Makes sure the head and tail points to not first.}
            \textcolor{keywordflow}{if} ( head == first )    head = first->next;
            \textcolor{keywordflow}{if} ( tail == first )    tail = first->prev;

            \textcolor{comment}{// Removes the node from this list and inserts it at the back of list.}
            list.PushNodeBack(first);

        \}
        \textcolor{comment}{// Copy the list across to this list.}
        head = list.head;
        tail = list.tail;
        \textcolor{comment}{// Stop the destructor deleting the node.}
        list.head = NULL;
        list.tail = NULL;
    \}



    \textcolor{keyword}{static} \textcolor{keywordtype}{string}* ListToString ( LinkedList<string>& list )
    \{
        LinkedListNode<string>* node = list.head;
        \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} size = 0;
        \textcolor{keywordtype}{string}* str;

        \textcolor{keywordflow}{while} ( node != NULL )
        \{
            size+=node->value.size();
            node = node->next;
        \}

        str = \textcolor{keyword}{new} string(size, \textcolor{charliteral}{'\(\backslash\)0'});
        node = list.head;
        \textcolor{keywordtype}{int} i = 0;
        \textcolor{keywordflow}{while} ( node != NULL )
        \{
            \textcolor{keywordflow}{for} ( uint jj = 0; jj < node->value.size(); jj++ )
            \{
                (*str)[i] = node->value[jj];
                i++;
            \}
            node = node->next;
        \}
        \textcolor{keywordflow}{return} str;
    \}
\};
\}
\end{DoxyCodeInclude}
 