\hypertarget{_2mnt_2c_2Users_2soyuz_2Desktop_2Star_Tracker_Microcontroller_2libs_2image_processing_2blob_8h-example}{}\section{/mnt/c/\+Users/soyuz/\+Desktop/\+Star\+\_\+\+Tracker\+\_\+\+Microcontroller/libs/image\+\_\+processing/blob.\+h}
This class is to provide details on a single blob. To do get this information, it must use the grassfire method. This method looks at the pixels adjacent to the start pixel and if they are within the bounds, it will add them to a queue. When it is added to the queue it will set the pixel to 0. Once it is done this, it will have the dimentions of the pixel.

To find the centroid of the pixel, it uses a weighted average of\+: (prevous\+\_\+centroid $\ast$ previous\+\_\+intensity + add\+\_\+point $\ast$ add\+\_\+intensity) / (previous\+\_\+intensity + add\+\_\+intensity).

In this process the image is destroyed as all blobs are set to 0.

\begin{DoxyVerb}const uint array_size = 100;
ArrayList<Blob, array_size> blobs;
Blob::FindBlobs<array_size>(img.PercentThreshold<array_size>(0.5, histogram), &img, &array_size);
blobs.Get(0).get_centroid_x(); // The center weighted pixel on the x axis.
blobs.Get(0).get_centroid_y(); // The center weighted pixel on the y axis.
\end{DoxyVerb}


\begin{DoxyAuthor}{Author}
Tom Creusot
\end{DoxyAuthor}

\begin{DoxyCodeInclude}
\textcolor{comment}{/*}
\textcolor{comment}{ *  To search for and store details on a blob.}
\textcolor{comment}{ *  @file   blob.h}
\textcolor{comment}{ *  @author Tom Creusot}
\textcolor{comment}{ *}
\textcolor{comment}{ *  @reference}
\textcolor{comment}{ *              Uses simmilar logic to:}
\textcolor{comment}{ *              http://what-when-how.com/}
\textcolor{comment}{                introduction-to-video-and-image-processing/}
\textcolor{comment}{                blob-analysis-introduction-to-video-and-image-processing-part-1/}
\textcolor{comment}{ */}

\textcolor{preprocessor}{#pragma once}

\textcolor{comment}{// #include <queue>}
\textcolor{preprocessor}{#include <iostream>}

\textcolor{preprocessor}{#include "\hyperlink{util_8h}{libs/util/util.h}"}
\textcolor{preprocessor}{#include "\hyperlink{point_8h}{libs/util/point.h}"}
\textcolor{preprocessor}{#include "\hyperlink{array__list_8h}{libs/util/array\_list.h}"}
\textcolor{preprocessor}{#include "\hyperlink{image_8h}{image.h}"}


\textcolor{keyword}{using namespace }\hyperlink{namespaceutil}{util};
\textcolor{keyword}{using namespace }\hyperlink{namespacestd}{std};
\textcolor{keyword}{namespace }\hyperlink{namespaceimage__processing}{image\_processing}
\{

\textcolor{keyword}{class }Blob
\{
\textcolor{comment}{// protected:}
\textcolor{keyword}{public}:
    \hyperlink{classutil_1_1Point}{Point<uint>} origin;
    uint width;
    uint height;
    uint pixels;
    uint intensity;
    \hyperlink{classutil_1_1Point}{Point<decimal>} centroid;


\textcolor{keyword}{public}:
    \textcolor{keyword}{template}<const u\textcolor{keywordtype}{int} N1, const u\textcolor{keywordtype}{int} N2>
    \textcolor{keyword}{static} \textcolor{keywordtype}{void} FindBlobs ( byte threshold, Image* img, \hyperlink{classutil_1_1ArrayList}{ArrayList<Blob, N1>}* list )
    \{
        \textcolor{keywordflow}{for} ( uint y = 0; y < img->GetHeight(); y++ )
        \{
            \textcolor{keywordflow}{for} ( uint x = 0; x < img->GetWidth(); x++ )
            \{
                \textcolor{comment}{// Is the pixel valid?}
                \textcolor{keywordflow}{if} ( img->GetPixel(x, y) > threshold )
                \{
                    Blob blob(x, y);
                    blob.SpreadGrassFire<N2> ( threshold, img );
                    list->\hyperlink{classutil_1_1ArrayList_a75e2f1682ebe7a982b6fd301d416d536}{PushBack}(blob);
                \}
            \}
        \}
    \}


    Blob                    ( );


    Blob                    ( uint x, uint y );




    \textcolor{comment}{// /// @return The number of pixels in the blob.}
    \textcolor{comment}{// uint     inline  get\_pixels          ( ) const   \{ return pixels;        \}}
    \textcolor{comment}{// /// @return The intensity of all the pixels added together.}
    \textcolor{comment}{// uint     inline  get\_intensity       ( ) const   \{ return intensity;     \}}
    \textcolor{comment}{// /// @return The actual center of the blob x.}
    \textcolor{comment}{// decimal  inline  get\_centroid\_x      ( ) const   \{ return centroid.x;    \}}
    \textcolor{comment}{// /// @return The actual center of the blob y.}
    \textcolor{comment}{// decimal  inline  get\_centroid\_y      ( ) const   \{ return centroid.y;    \}}
    \textcolor{comment}{// /// @return The left of the blob.}
    \textcolor{comment}{// decimal inline   get\_origin\_x        ( ) const   \{ return origin.x;      \}}
    \textcolor{comment}{// /// @return The top of the blob.}
    \textcolor{comment}{// decimal inline   get\_origin\_y        ( ) const   \{ return origin.y;      \}}
    \textcolor{comment}{//}
    \textcolor{comment}{// /// @return The bounding width of the blob.}
    \textcolor{comment}{// uint inline  get\_width           ( ) const   \{ return width;         \}}
    \textcolor{comment}{// /// @return The bounding height of the blob.}
    \textcolor{comment}{// uint inline  get\_height          ( ) const   \{ return height;        \}}



    \textcolor{keyword}{template}<const u\textcolor{keywordtype}{int} N>
    \textcolor{keywordtype}{void} SpreadGrassFire ( uint threshold, Image* img )
    \{
        \hyperlink{classutil_1_1ArrayList}{util::ArrayList<util::Point<util::uint>}, N> q;

        uint minX = round(centroid.\hyperlink{classutil_1_1Point_aacd055853a71c08675e1210ee7d7777b}{x}), minY = round(centroid.\hyperlink{classutil_1_1Point_abf5df9373ece02d9b87f367cf12dd319}{y});
        uint maxX = minX, maxY = minY;

        q.\hyperlink{classutil_1_1ArrayList_a75e2f1682ebe7a982b6fd301d416d536}{PushBack}(\hyperlink{classutil_1_1Point}{Point<uint>}(minX, minY));

        \textcolor{keywordflow}{while} ( !q.\hyperlink{classutil_1_1ArrayList_a8e33bd4f9e6a67140696cf24b8cc66b1}{IsEmpty}() )
        \{
            \hyperlink{classutil_1_1Point}{util::Point<util::uint>} pt = q.\hyperlink{classutil_1_1ArrayList_ac03915c0d58b62bf78148737be86fafc}{PopBack}();
            \textcolor{keywordflow}{if}(img->ValidPixel(pt.\hyperlink{classutil_1_1Point_aacd055853a71c08675e1210ee7d7777b}{x}, pt.\hyperlink{classutil_1_1Point_abf5df9373ece02d9b87f367cf12dd319}{y})&&img->GetPixel(pt.\hyperlink{classutil_1_1Point_aacd055853a71c08675e1210ee7d7777b}{x}, pt.\hyperlink{classutil_1_1Point_abf5df9373ece02d9b87f367cf12dd319}{y})>threshold)
            \{   \textcolor{comment}{// 4 directional}

                q.\hyperlink{classutil_1_1ArrayList_a75e2f1682ebe7a982b6fd301d416d536}{PushBack}(\hyperlink{classutil_1_1Point}{util::Point<uint>}(pt.\hyperlink{classutil_1_1Point_aacd055853a71c08675e1210ee7d7777b}{x} + 1, pt.
      \hyperlink{classutil_1_1Point_abf5df9373ece02d9b87f367cf12dd319}{y}));
                q.\hyperlink{classutil_1_1ArrayList_a75e2f1682ebe7a982b6fd301d416d536}{PushBack}(\hyperlink{classutil_1_1Point}{util::Point<uint>}(pt.\hyperlink{classutil_1_1Point_aacd055853a71c08675e1210ee7d7777b}{x} - 1, pt.
      \hyperlink{classutil_1_1Point_abf5df9373ece02d9b87f367cf12dd319}{y}));
                q.\hyperlink{classutil_1_1ArrayList_a75e2f1682ebe7a982b6fd301d416d536}{PushBack}(\hyperlink{classutil_1_1Point}{util::Point<uint>}(pt.\hyperlink{classutil_1_1Point_aacd055853a71c08675e1210ee7d7777b}{x}, pt.
      \hyperlink{classutil_1_1Point_abf5df9373ece02d9b87f367cf12dd319}{y} + 1));
                q.\hyperlink{classutil_1_1ArrayList_a75e2f1682ebe7a982b6fd301d416d536}{PushBack}(\hyperlink{classutil_1_1Point}{util::Point<uint>}(pt.\hyperlink{classutil_1_1Point_aacd055853a71c08675e1210ee7d7777b}{x}, pt.
      \hyperlink{classutil_1_1Point_abf5df9373ece02d9b87f367cf12dd319}{y} - 1));
                \textcolor{comment}{// Diagonals}
                q.\hyperlink{classutil_1_1ArrayList_a75e2f1682ebe7a982b6fd301d416d536}{PushBack}(\hyperlink{classutil_1_1Point}{util::Point<uint>}(pt.\hyperlink{classutil_1_1Point_aacd055853a71c08675e1210ee7d7777b}{x} - 1, pt.
      \hyperlink{classutil_1_1Point_abf5df9373ece02d9b87f367cf12dd319}{y} - 1));
                q.\hyperlink{classutil_1_1ArrayList_a75e2f1682ebe7a982b6fd301d416d536}{PushBack}(\hyperlink{classutil_1_1Point}{util::Point<uint>}(pt.\hyperlink{classutil_1_1Point_aacd055853a71c08675e1210ee7d7777b}{x} - 1, pt.
      \hyperlink{classutil_1_1Point_abf5df9373ece02d9b87f367cf12dd319}{y} + 1));
                q.\hyperlink{classutil_1_1ArrayList_a75e2f1682ebe7a982b6fd301d416d536}{PushBack}(\hyperlink{classutil_1_1Point}{util::Point<uint>}(pt.\hyperlink{classutil_1_1Point_aacd055853a71c08675e1210ee7d7777b}{x} + 1, pt.
      \hyperlink{classutil_1_1Point_abf5df9373ece02d9b87f367cf12dd319}{y} - 1));
                q.\hyperlink{classutil_1_1ArrayList_a75e2f1682ebe7a982b6fd301d416d536}{PushBack}(\hyperlink{classutil_1_1Point}{util::Point<uint>}(pt.\hyperlink{classutil_1_1Point_aacd055853a71c08675e1210ee7d7777b}{x} + 1, pt.
      \hyperlink{classutil_1_1Point_abf5df9373ece02d9b87f367cf12dd319}{y} + 1));


                minX        = (pt.\hyperlink{classutil_1_1Point_aacd055853a71c08675e1210ee7d7777b}{x} < minX ? pt.\hyperlink{classutil_1_1Point_aacd055853a71c08675e1210ee7d7777b}{x} : minX);
                minY        = (pt.\hyperlink{classutil_1_1Point_abf5df9373ece02d9b87f367cf12dd319}{y} < minY ? pt.\hyperlink{classutil_1_1Point_abf5df9373ece02d9b87f367cf12dd319}{y} : minY);
                maxX        = (pt.\hyperlink{classutil_1_1Point_aacd055853a71c08675e1210ee7d7777b}{x} > maxX ? pt.\hyperlink{classutil_1_1Point_aacd055853a71c08675e1210ee7d7777b}{x} : maxX);
                maxY        = (pt.\hyperlink{classutil_1_1Point_abf5df9373ece02d9b87f367cf12dd319}{y} > maxY ? pt.\hyperlink{classutil_1_1Point_abf5df9373ece02d9b87f367cf12dd319}{y} : maxY);

                \textcolor{keyword}{const} byte px = img->GetPixel(pt.\hyperlink{classutil_1_1Point_aacd055853a71c08675e1210ee7d7777b}{x}, pt.\hyperlink{classutil_1_1Point_abf5df9373ece02d9b87f367cf12dd319}{y});
                \textcolor{comment}{// Setting new centroid.}
                centroid.\hyperlink{classutil_1_1Point_aacd055853a71c08675e1210ee7d7777b}{x} = FindCentroid(centroid.\hyperlink{classutil_1_1Point_aacd055853a71c08675e1210ee7d7777b}{x}, intensity, pt.\hyperlink{classutil_1_1Point_aacd055853a71c08675e1210ee7d7777b}{x}, px);
                centroid.\hyperlink{classutil_1_1Point_abf5df9373ece02d9b87f367cf12dd319}{y} = FindCentroid(centroid.\hyperlink{classutil_1_1Point_abf5df9373ece02d9b87f367cf12dd319}{y}, intensity, pt.\hyperlink{classutil_1_1Point_abf5df9373ece02d9b87f367cf12dd319}{y}, px);
                \textcolor{comment}{// Setting intensity.}
                intensity += (uint) px;
                \textcolor{comment}{// Setting pixels}
                pixels++;
                \textcolor{comment}{// Stops reading same px}
                img->SetPixel(pt.\hyperlink{classutil_1_1Point_aacd055853a71c08675e1210ee7d7777b}{x}, pt.\hyperlink{classutil_1_1Point_abf5df9373ece02d9b87f367cf12dd319}{y}, 0);
            \}
        \}
        \textcolor{keywordflow}{if} ( pixels == 0 )  width = height = 0;
        \textcolor{keywordflow}{else}
        \{
            width = maxX - minX + 1;
            height = maxY - minY + 1;
        \}
    \}

    decimal FindCentroid ( decimal centroid, uint intense,
                                             uint point, byte weight );





    \textcolor{keyword}{template}<const \textcolor{keywordtype}{int} N>
    \textcolor{keyword}{static} \textcolor{keywordtype}{void} ToPointList (   \hyperlink{classutil_1_1ArrayList}{ArrayList<Blob, N>}& blobs,
                                        \hyperlink{classutil_1_1ArrayList}{ArrayList}<\hyperlink{classutil_1_1Point}{Point<decimal>}, N>* points )
    \{
        \textcolor{keywordflow}{for} ( uint i = 0; i < blobs.\hyperlink{classutil_1_1ArrayList_ae098e879892c23b682edc4b023a770de}{Size}(); i++ )
        \{
            points->PushBack(blobs.\hyperlink{classutil_1_1ArrayList_ac5a4259af59f7bac9df06851c29d9e37}{Get}(i).centroid);
        \}
    \}


    \textcolor{keyword}{static} \textcolor{keywordtype}{bool} SortByIntensity ( Blob& larger, Blob& smaller );

\};
\}
\end{DoxyCodeInclude}
 